% Constants
% Speed of light (m/s)
c = 299792458;
% Time step between epochs
dt = 30.0;
% Number of satellites
ns = 7;
% Earth rotation rate (rad/s)
earth_rot_rate = 7.2921151467E-5;
% A priori receiver coordinates (m)
ZUGS_xr = 4235956.688;
ZUGS_yr = 834342.467;
ZUGS_zr = 4681540.682;
% Recorded data
ZUGS_c1 = importdata('ZUGS_C1');
ZUGS_satt = importdata('ZUGS_SATT');
ZUGS_xs_raw = importdata('ZUGS_SATX');
ZUGS_ys_raw = importdata('ZUGS_SATY');
ZUGS_zs_raw = importdata('ZUGS_SATZ');
epochs = importdata('Epochs.txt');
epochs = epochs(:,1);
%% 3 (a): Correct satellite positions for Earth rotation during light
%% travel time.
% Raw geometric distance:
rho_sr_raw = sqrt((ZUGS_xs_raw - ZUGS_xr).^2 ...
+ (ZUGS_ys_raw - ZUGS_yr).^2 + (ZUGS_zs_raw - ZUGS_zr).^2);
dOmega = rho_sr_raw * earth_rot_rate / c;
% Correct the coordinates.
ZUGS_xs = ZUGS_xs_raw .* cos(dOmega) + ZUGS_ys_raw .* sin(dOmega);
ZUGS_ys = - ZUGS_xs_raw .* sin(dOmega) + ZUGS_ys_raw .* cos(dOmega);
ZUGS_zs = ZUGS_zs_raw;
% Recompute the geometric distance.
rho_sr = sqrt((ZUGS_xs - ZUGS_xr).^2 ...
+ (ZUGS_ys - ZUGS_yr).^2 + (ZUGS_zs - ZUGS_zr).^2);
%% 3 (b) Compute the derivates of the observation equation.
% Todo: change this back to c? Need to adjust calculations below!
dPdt = 1;
cs =[1 1 1 1 1 1 1] * dPdt;
dPdx = -(ZUGS_xs - ZUGS_xr) ./ rho_sr;
dPdy = -(ZUGS_ys - ZUGS_yr) ./ rho_sr;
dPdz = -(ZUGS_zs - ZUGS_zr) ./ rho_sr;
% Correct pseudorange data with satellite clock correction.
c1_corrected = ZUGS_c1 + (c * ZUGS_satt); % changed sign before bracket
%% Solve the normal equations.
for i=1:length(epochs);
    % Setup the grand design matrix A for every epoch.
    A(:,1)=dPdx(i,:);
    A(:,2)=dPdy(i,:);
    A(:,3)=dPdz(i,:);
    A(:,4)=cs;
    % Solve normal equation.
    deltay(i,:) = c1_corrected(i,:) - rho_sr(i,:); %#ok<*SAGROW>
    atransp = transpose(A);
    N = atransp*A;
    % deltap are the deviations of computed from a priori coordinates. 
    deltap(:,i) = (N \ atransp) * transpose(deltay(i,:));
    % Compute the residuals.
    epsilon(:,i) = transpose(deltay(i,:)) - (A * deltap(:,i));
    m0(:,i) = sqrt(transpose(epsilon(:,i)) * epsilon(:,i) ./ 3);
    % Formal errors
    Q = N \ eye(size(N));  %changed, so singularity warning doesn't show 
    sigmax(:,i) = m0(:,i) * Q(1,1);
    sigmay(:,i) = m0(:,i) * Q(2,2);
    sigmaz(:,i) = m0(:,i) * Q(3,3);
    sigmat(:,i) = m0(:,i) * Q(4,4);
end
%% Calculate station coordinates for each epoch.
% Add or subtract the difference???
ZUGS_gps_coords = [ZUGS_xr + deltap(1,:); ZUGS_yr + deltap(2,:); ... 
    ZUGS_zr + deltap(3,:)]; 
%% For ex 2.2: Plot satellite positions to perhaps explain why y accuracy 
%% is better than x?
% Drift may be because troposphere not yet corrected and not constant??

%% B: 2.1 Single set of coordinates.
% Simply average coordinates?
ZUGS_single_gps_coords = [mean(ZUGS_gps_coords(1,:)); ...
    mean(ZUGS_gps_coords(2,:)); mean(ZUGS_gps_coords(3,:))];
% "Again give coordinate corrections and the formal errors."

%% Calculate coordinates with tropospheric correction.
% Calculate cos(z), the tropospheric zenith angle for each epoch.
% Need a single set of station coordinates
ZUGS_xr_gps = ZUGS_single_gps_coords(1,:);
ZUGS_yr_gps = ZUGS_single_gps_coords(2,:);
ZUGS_zr_gps = ZUGS_single_gps_coords(3,:);
% OR use the a priori coordinates
% ZUGS_xr_gps = ZUGS_xr
xyz = sqrt((ZUGS_xr_gps).^2 + (ZUGS_yr_gps).^2 + (ZUGS_zr_gps).^2);
rho_sr = sqrt((ZUGS_xs - ZUGS_xr_gps).^2 ...
+ (ZUGS_ys - ZUGS_yr_gps).^2 + (ZUGS_zs - ZUGS_zr_gps).^2);
cos_z = (ZUGS_xr_gps./xyz) .* (ZUGS_xs - ZUGS_xr_gps)./rho_sr ...
    + (ZUGS_yr_gps./xyz) .* (ZUGS_ys - ZUGS_yr_gps)./rho_sr ...
    + (ZUGS_zr_gps./xyz) .* (ZUGS_zs - ZUGS_zr_gps)./rho_sr;
% Tropospheric correction:
tropo_corr = 2.3 ./ cos_z;
% Apply correction.
c1_corr_tropo = ZUGS_c1 + (c * ZUGS_satt) + tropo_corr;
% Redo the coordinate calculation.
% Call least-squares again as function (?)

% Part B, 2.3
% All the corrections need to be applied to the pseudorange observations
% before the LS-alogrithm is executed???
% Compute satellite inertial velocities:
delta_epoch = 30.0;
for i = 1:length(epochs)-1;
    % uses 2point finite differences -> no derivative for last epoch!    
    inert_vel_x(i,:) = (ZUGS_xs(i+1,:) - ZUGS_xs(i,:)) / dt;
    inert_vel_y(i,:) = (ZUGS_ys(i+1,:) - ZUGS_ys(i,:)) / dt;
    inert_vel_z(i,:) = (ZUGS_zs(i+1,:) - ZUGS_zs(i,:)) / dt;
    % Correct for earth's rotation
    inert_vel_x_corrected(i,:) = inert_vel_x(i,:) - earth_rot_rate .* ZUGS_ys(i,:);
    inert_vel_y_corrected(i,:) = inert_vel_y(i,:) + earth_rot_rate .* ZUGS_xs(i,:);
    inert_vel_z_corrected(i,:) = inert_vel_z(i,:);
end
% Discard last epoch from sattelite postions to have same matrix dimensions
ZUGS_xs_short = ZUGS_xs(1:end-1,:);
ZUGS_ys_short = ZUGS_ys(1:end-1,:);
ZUGS_zs_short = ZUGS_zs(1:end-1,:);

% Compute relativistic correction according to given formula
for i = 1:ns;
    delta_tk(:,i) = -2 * (ZUGS_xs_short(:,i) .* inert_vel_x_corrected(:,i) ...
        + ZUGS_ys_short(:,i) .* inert_vel_y_corrected(:,i) ...
        + ZUGS_zs_short(:,i) .* inert_vel_z_corrected(:,i)) / c^2;
    % relativistic correction in meters
    delta_tk_m(:,i) = delta_tk(:,i) .* c;
end
